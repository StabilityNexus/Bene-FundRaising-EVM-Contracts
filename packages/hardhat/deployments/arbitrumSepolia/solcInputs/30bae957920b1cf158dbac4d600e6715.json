{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/FundingVault.sol": {
      "content": "\n//SPDX-License-Identifier: MIT\n\n/**\n * Layout of the contract\n * version\n * imports\n * errors\n * interfaces, libraries, and contracts\n * type declarations\n * state variables\n * events\n * modifiers\n * functions\n *\n * layout of functions\n * constructor\n * receive function\n * fallback function\n * external functions\n * public functions\n * internal functions\n * private functions\n * view functions\n * pure functions\n * getters\n */\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title FundingVault\n * @author Muhammad Zain Nasir\n * @notice  A contract that allows users to deposit funds and receive participation tokens in return box creator can call WithdrawFunds if there enough funds collected\n */\ncontract FundingVault{\n\n // Errors //\n    error FundingVault__AmountCannotBeZero(); //\n    error FundingVault__minFundingAmountReached();\n    error FundingVault__minFundingAmountNotReached();\n    error FundingVault__deadlineNotPassed(); //\n    error FundingVault__deadlinePassed(); \n    error FundingVault__NotEnoughTokens(); //\n    error FundingVault__noTokenBalance();\n    error FundingVault__fundsWithdrawn();\n    error FundingVault__TokenTransferFailed();\n    error FundingVault__EthTransferFailed();\n    error FundingVault__EthTransferToDeveloperFailed();\n    error FundingVault__EthTransferToWithdrawlFailed();\n\n\n    // State Variables //\n    IERC20 private immutable participationToken;\n    uint256 private participationTokenAmount;\n    uint256 private blockLimit;\n    uint256 private minFundingAmount; //The minimum amount of ETH required in the contract to enable withdrawal.\n    uint256 private exchangeRate; //The exchange rate of ERG per token\n    address private projectOwner;\n    address private withdrawlAddress;\n    address private developerFeeAddress; //develper address\n    uint256 private developerFeePercentage; \n    string  private projectURL;\n    string private projectTitle;\n    string private projectDescription;\n    bool private fundsWithdrawn;\n\n\n    /** \n    * @dev A vault is represented as a struct  \n    */ \n\n    struct Vault{\n        address withdrawlAddress;\n        address participationToken;\n        uint256 participationTokenAmount;  \n        uint256 minFundingAmount;\n        uint256 blockLimit;\n        uint256 exchangeRate;\n        string projectURL;\n        string projectTitle;\n        string projectDescription;\n    }\n    \n\n\n    // Events //\n    event TokensPurchased(address indexed from, uint256 indexed amount);\n    event Refund(address indexed user, uint256 indexed amount);\n    event FundsWithdrawn(address indexed user, uint256 amount);\n\n\n\n    modifier deadlinePassed() {\n        if (block.number < blockLimit) {\n            revert FundingVault__deadlineNotPassed();\n        }\n        _;\n    }\n    modifier deadlineNotPassed() {\n        if (block.number > blockLimit) {\n            revert FundingVault__deadlinePassed();\n        }\n        _;\n    }\n\n\n    // Functions //\n\n     /**\n     * @param _participationToken The token that will be used as participation token to incentivise donators\n     * @param _participationTokenAmount Theinitial  participation token amount which will be in fundingVault\n     * @param _minFundingAmount The minimum amount required to make withdraw of funds possible\n     * @param _blockLimit The date (block height) limit until which withdrawal or after which refund is allowed.\n     * @param _withdrawlAddress The address for withdrawl of funds\n     * @param _developerFeeAddress the address for the developer fee\n     * @param _developerFeePercentage the percentage fee for the developer.\n     * @param _projectURL A link or hash containing the project's information (e.g., GitHub repository).\n     */\n    \n     constructor(\n        address _participationToken,\n        uint256 _participationTokenAmount,  \n        uint256 _minFundingAmount,\n        uint256 _blockLimit,\n        uint256 _exchangeRate,\n        address _withdrawlAddress,\n        address _developerFeeAddress, \n        uint256 _developerFeePercentage, \n        string memory _projectURL,\n        string memory _projectTitle,\n        string memory _projectDescription\n    ) {\n        \n        participationToken  = IERC20(_participationToken);\n        participationTokenAmount  = _participationTokenAmount ;\n        minFundingAmount = _minFundingAmount;\n        blockLimit = _blockLimit;\n        exchangeRate = _exchangeRate;\n        withdrawlAddress = _withdrawlAddress;\n        developerFeeAddress =  _developerFeeAddress;\n        developerFeePercentage = _developerFeePercentage;\n        projectURL = _projectURL;\n        projectTitle = _projectTitle;\n        projectDescription = _projectDescription;\n    }\n\n    \n    /**\n     * @dev Allows users to deposit Ether and purchase participation tokens based on exchange rate\n     */\n    function purchaseTokens() external payable {\n        if (msg.value == 0){\n            revert FundingVault__AmountCannotBeZero();\n        }\n\n        \n        uint256 tokenAmount = msg.value * exchangeRate;\n\n        if (participationToken.balanceOf(address(this)) < tokenAmount)\n        {\n            revert FundingVault__NotEnoughTokens();\n        }\n\n        \n        bool tokenTransferSuccess = participationToken.transfer(msg.sender, tokenAmount);\n        if (!tokenTransferSuccess){\n            revert FundingVault__TokenTransferFailed();\n        }\n        \n        emit TokensPurchased(msg.sender, tokenAmount);\n    }\n\n    /**\n     * @dev Allows users to exchange tokens for Eth (at exchange rate) if and only if the deadline has passed and the minimum number of tokens has not been sold.\n     */\n\n    function refundTokens() external payable deadlineNotPassed{\n\n        if(address(this).balance >= minFundingAmount){\n        revert FundingVault__minFundingAmountReached();\n        }\n        uint tokensHeld = participationToken.balanceOf(msg.sender);\n        if (tokensHeld == 0){\n        revert FundingVault__noTokenBalance();\n        }\n\n        uint256 refundAmount = tokensHeld * exchangeRate;\n\n       \n        bool tokenTransferSuccess = participationToken.transferFrom(msg.sender, address(this), tokensHeld);\n        if (!tokenTransferSuccess){\n            revert FundingVault__TokenTransferFailed();\n        }\n       \n        (bool ethTransferSuccess, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        if (!ethTransferSuccess){\n            revert FundingVault__EthTransferFailed();\n        }\n        \n        emit Refund(msg.sender, refundAmount);       \n    }\n\n    /**\n     * @dev Allows Project owners to withdraw Eth if and only if the minimum number of tokens has been sold.\n     \n     */\n\n    function withdrawFunds() external {\n        uint256 fundsCollected = address(this).balance;\n        \n        if(fundsCollected < minFundingAmount){\n            revert FundingVault__minFundingAmountNotReached();\n        }\n        \n        if(fundsWithdrawn == true){\n            revert FundingVault__fundsWithdrawn();\n        }\n        \n        uint256 developerFee = (fundsCollected * developerFeePercentage) / 100;\n        uint256 amountToWithdraw = fundsCollected - developerFee;\n\n        (bool successA, ) = payable(developerFeeAddress).call{value: developerFee}(\"\");\n        if (!successA){\n            revert FundingVault__EthTransferToDeveloperFailed();\n        }\n        (bool successB, ) = payable(withdrawlAddress).call{value: amountToWithdraw}(\"\");\n        if (!successB){\n            revert FundingVault__EthTransferToWithdrawlFailed();\n        }\n        fundsWithdrawn = true;\n        emit FundsWithdrawn(msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @dev Allows Project owners to withdraw unsold tokens from the contract at any time.\n     * @param UnsoldTokenAmount amount to withdraw\n    */\n\n     function withdrawUnsoldTokens(uint256 UnsoldTokenAmount) external  {\n        uint tokensHeld = participationToken.balanceOf(address(this));\n        if (tokensHeld < UnsoldTokenAmount){\n            revert FundingVault__NotEnoughTokens();\n        }\n        bool tokenTransferSuccess = participationToken.transferFrom(address(this), withdrawlAddress, UnsoldTokenAmount);\n        if (!tokenTransferSuccess){\n            revert FundingVault__TokenTransferFailed();\n        }\n       \n     }\n\n     /**\n     * @dev Allows Project owners to  add more tokens to the contract at any time.\n     * @param additionalTokens amount to add\n    */\n    function addTokens(uint256 additionalTokens) external {\n        bool tokenTransferSuccess = participationToken.transferFrom(msg.sender, address(this), additionalTokens);\n        if (!tokenTransferSuccess){\n            revert FundingVault__TokenTransferFailed();\n        }\n    }\n\n    /**\n     * @notice Get funding vault details\n     * @dev to access all neccassary parameters of the funding vault\n     */ \n    function getVaults() external view returns(Vault memory)\n    {\n        Vault memory VaultDetails;\n        VaultDetails.withdrawlAddress = withdrawlAddress;\n        VaultDetails.participationToken  = address(participationToken);\n        VaultDetails.participationTokenAmount  = participationTokenAmount ;\n        VaultDetails.minFundingAmount = minFundingAmount;\n        VaultDetails.blockLimit = blockLimit;\n        VaultDetails.exchangeRate = exchangeRate;\n        VaultDetails.projectURL = projectURL;\n        VaultDetails.projectTitle = projectTitle;\n        VaultDetails.projectDescription = projectDescription;\n        return VaultDetails;\n    }\n\n}"
    },
    "contracts/FundingVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n\n/**\n * Layout of the contract\n * version\n * imports\n * errors\n * interfaces, libraries, and contracts\n * type declarations\n * state variables\n * events\n * modifiers\n * functions\n *\n * layout of functions\n * external functions\n * public functions\n * internal functions\n * private functions\n * view functions\n * pure functions\n * getters\n */\n\npragma solidity ^0.8.20;\n\nimport {FundingVault} from \"./FundingVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title FundingVaultFactory\n * @author Muhammad Zain Nasir\n * @notice This is the FundingVaultFactory contract that will be used for deployment and keeping track of all the funding vaults.\n */\ncontract FundingVaultFactory{\n    // Errors //\n    error FundingVaultFactory__CannotBeAZeroAddress();\n    error FundingVaultFactory__deadlineCannotBeInThePast();\n    error FundingVaultFactory__MinFundingAmountCanNotBeZero();\n    error FundingVault__TokenTransferFailed();\n    error FundingVaultFactory__InvalidIndex();\n\n    struct Vault{\n        address vaultAddress;\n        string title;\n        string description;\n        uint256 deadline;\n    }\n\n\n    // State Variables //\n    mapping(uint256 => Vault) private vaults;\n\n    IERC20 private participationToken;\n    uint256 private s_fundingVaultIdCounter;\n\n    \n\n\n\n    // Events //\n    event FundingVaultDeployed(address indexed fundingVault);\n    event TransferTokens(address indexed token, address indexed recepient, uint256 amount);\n\n    // Functions //\n\n    /**\n     * @param _participationToken The token that will be used as participation token to incentivise donators\n     * @param _participationTokenAmount Theinitial  participation token amount which will be in fundingVault\n     * @param _minFundingAmount The minimum amount required to make withdraw of funds possible\n     * @param _blockLimit The date (block height) limit until which withdrawal or after which refund is allowed.\n     * @param _withdrawlAddress The address for withdrawl of funds\n     * @param _developerFeeAddress the address for the developer fee\n     * @param _developerFeePercentage the percentage fee for the developer.\n     * @param _projectURL A link or hash containing the project's information (e.g., GitHub repository).\n     */\n    function deployFundingVault(\n        address _participationToken,\n        uint256 _participationTokenAmount,  \n        uint256 _minFundingAmount,\n        uint256 _blockLimit,\n        uint256 _exchangeRate,\n        address _withdrawlAddress,\n        address _developerFeeAddress, \n        uint256 _developerFeePercentage, \n        string memory _projectURL,\n        string memory _projectTitle,\n        string memory _projectDescription\n    ) external returns (address) {\n        if (_participationToken == address(0) || _withdrawlAddress == address(0) || _developerFeeAddress == address(0)){\n            revert FundingVaultFactory__CannotBeAZeroAddress();\n        }\n        if (block.number > _blockLimit) {\n            revert FundingVaultFactory__deadlineCannotBeInThePast();\n        }\n        if (_minFundingAmount == 0) {\n            revert FundingVaultFactory__MinFundingAmountCanNotBeZero();\n        }\n\n\n\n        s_fundingVaultIdCounter++;\n        uint256 fundingVaultId = s_fundingVaultIdCounter;\n        participationToken = IERC20(_participationToken);\n\n        FundingVault fundingVault = new FundingVault(\n        _participationToken,\n        _participationTokenAmount,  \n        _minFundingAmount,\n        _blockLimit,\n        _exchangeRate,\n        _withdrawlAddress,\n        _developerFeeAddress, \n        _developerFeePercentage, \n        _projectURL,\n        _projectTitle,\n        _projectDescription\n        );\n\n        \n        transferParticipationTokens(msg.sender, address(fundingVault), _participationTokenAmount);\n\n        Vault storage vault = vaults[fundingVaultId];\n        vault.vaultAddress = address(fundingVault);\n        vault.title = _projectTitle;\n        vault.description = _projectDescription;\n        vault.deadline = _blockLimit;\n        \n        emit FundingVaultDeployed(address(fundingVault));     \n        return address(fundingVault);\n    }\n\n     /**\n     * @notice Get list of all funding vaults\n     * @dev to access the list of all the available funding vaults on the platform \n     */ \n    function getVaults(uint256 start, uint256 end) external view returns(Vault[] memory)\n    {\n        if(end > s_fundingVaultIdCounter || start > end || start == 0)\n        {\n            revert FundingVaultFactory__InvalidIndex();\n        }\n        Vault[] memory allVaults = new Vault[](end - start + 1);\n\n        for(uint i = start; i <= end;i++)\n        {\n            allVaults[i - start] = vaults[i];\n        }\n        return allVaults;\n    }\n\n    function transferParticipationTokens(address from, address to, uint256 amount) private{\n        bool tokenTransferSuccess = participationToken.transferFrom(from, to, amount);\n        if (!tokenTransferSuccess){\n            revert FundingVault__TokenTransferFailed();\n        }\n    }\n\n\n    // Getters //\n    function getFundingVault(uint256 _fundingVaultId) external view returns (address) {\n        return vaults[_fundingVaultId].vaultAddress;\n    }\n\n    function getTotalNumberOfFundingVaults() external view returns (uint256) {\n        return s_fundingVaultIdCounter;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}